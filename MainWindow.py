import sys, os
import numpy as np
import matlab.engine
from pint import UnitRegistry, PintError
from PySide2.QtWidgets import QApplication, QMainWindow, QMessageBox
from PySide2.QtCore import QThread, Slot
from PySide6.QtCore import Qt, QCoreApplication
from PySide2.QtWidgets import QTableWidgetItem
from PySide2.QtWidgets import QFileDialog

from sim.SaveData import SaveMat 
from sim.MotorOptimizer import MotorOpt
from sim.MotorModel import MotorCalcs_Vectorized
from gui.interface import Ui_UserInterface
from gui.optimization_worker import OptimizationWorker
from utils import state_manager
from utils import input_parser
from utils import material_manager
import tkinter as tk
import traceback

# Ensure icons and pixmaps are scaled correctly on large monitors
QCoreApplication.setAttribute(Qt.AA_EnableHighDpiScaling) 
QCoreApplication.setAttribute(Qt.AA_UseHighDpiPixmaps) 


class MainWindow(QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        self.ui = Ui_UserInterface()
        self.ui.setupUi(self)

        self.optimization_thread = None
        self.optimization_worker = None
        self.ureg = UnitRegistry()

        try:
            print("Starting MATLAB engine...")
            self.matlab_engine = matlab.engine.start_matlab()
            project_root = os.path.dirname(os.path.abspath(__file__)) 
            matlab_path = os.path.join(project_root, 'matlab')
            self.matlab_engine.addpath(matlab_path, nargout=0)
            print("MATLAB engine started.")
        except Exception as e:
            QMessageBox.critical(self, "MATLAB Error", f"Could not start MATLAB engine: {e}")
            self.matlab_engine = None
            self.ui.Execution.setEnabled(False)

        # Initialize derived material properties on the instance
        self.MagnetBr_T = 0.0
        self.MaxBMagnetIron_T = 0.0
        self.PresentBLaminationBackIron_T = 0.0
        self._update_all_material_properties() # Initial update

        # Table output (Simulation Tab)
        self.table_column_data_keys = [] 

        # Plotting Inputs (Results Tab)
        self.recent_excel = None # more recent excel file generated by simulation tab (where plotting tab will source its info)
        self.plot_checkboxes = [
            (self.ui.MinTrqMargin_Percent, "MinTrqMargin_Percent"),
            (self.ui.MeanTrqMargin_Percent, "MeanTrqMargin_Percent"),
            (self.ui.MinEffMtr_Percent, "MinEffMtr_Percent"),
            (self.ui.MeanEffMtr_Percent, "MeanEffMtr_Percent"),
            (self.ui.Weight_kg, "Weight_kg"),
            (self.ui.MagVol_m3, "MagVol_m3"),
            (self.ui.VDC_2, "VDC"),
            (self.ui.R_MtrLength_m, "R_MtrLength_m"),
            (self.ui.R_LaminatR_m, "R_LaminatR_m"),
            (self.ui.MaxTotalLoss_W, "MaxTotalLoss_W"),
        ]
        # Dictionary to map dropdown text to MATLAB variable names
        self.plot_dropdown_map = {
            "# of pole pairs": "I_PolePair",
            "Radial length of magnet": "R_MagnetRadialLength_m",
            "Wire copper radius": "R_WireCopperR_m",
            "Fill factor": "R_FillFactor",
            "Lamination tooth tip and wedge thickness": "R_LaminatToothWedgeThickness_m",
            "Lamination slot liner thickness": "R_LamSlotLinerThick_m",
            "Gear ratio": "R_GearRatio",
            "Magnet backiron inner radius": "MagBackIronInR_m",
            "Magnet backiron outer radius": "MagBackIranOutR_m",
            "Tooth width": "ToothWidth_m",
            "Lamination tooth tip radius": "LamTTipR_m",
            "Lamination slot radius": "LamSlotR_m",
            "Magnet inner radius": "MagInR_m",
            "Backiron thickness, lamination": "BackIronThickLam_m",
            "Backiron thickness, magnet assembly": "BackIronThickMag_m",
            "Lamination slot outer": "LamSlotOutR_m",
            "Lamination slot area": "LamSlotA_m2",
            "Winding Slot area": "WindSlotA_m2",
            "Arc length of lamination ID": "ArcLamID_m",
            "Arc length of one tooth pitch": "ArcToothPitch_m",
            "Approx width of slot opening": "SlotOpenWidth_m",
            "# of turns": "NumTurn",
            "Actual flux density": "ActualFluxDens",
            "Actual coil flux": "ActualCoilFlux",
            "Rated Torque per phase": "RateTrqPPhase_Nm",
            "Torque constant": "KT_Nm_A",
            "BackEMF constant": "KB_VLLPkNs_rad",
            "Phase inductance": "InducPh_H",
            "Phase resistance": "ResisPh_ohm",
            "Inertia": "Inertia_Nms2",
            "torque/inertia": "TrqPerInertia_1_s2",
            "Motor volume": "Volume_m3",
            "Stator surface area": "StatorSurfA_m2",
            "Fe weight": "FeWeight_kg",
            "Cu weight": "CuWeight_kg",
            "Rotor weight": "RotWeight_kg",
            "Current density": "CurrDens_A_m2",
            "Mean resistive losses": "MeanResLoss_W",
            "Mean back iron losses": "MeanBackIronLoss_W",
            "Mean fluid losses": "MeanFluidLoss_W",
        }
        self._connect_signals()

    def _calculate_num_objectives(self, opt_conf):
        """
        Calculates the number of objectives based on OptimizationConf.
        Mirrors the logic from MotorOpt.
        """
        num_obj = 0
        # SpeedReq_rpm_str will define NumPts for TorqueOpt
        speed_req_str = opt_conf.get("SpeedReq", "")
        num_pts = len([s for s in speed_req_str.split(',') if s.strip()]) if speed_req_str else 0

        if opt_conf.get("TorqueOpt"):
            num_obj += num_pts
        if opt_conf.get("Efficinecy_minOpt"):  # Assuming this means minimizing 1-efficiency
            num_obj += 1
        if opt_conf.get("Efficinecy_maxOpt"):
            num_obj += 1
        if opt_conf.get("WeightOpt"):
            num_obj += 1
        if opt_conf.get("MagWeightOpt"):
            num_obj += 1
        if opt_conf.get("VoltageOpt"): # Assuming minimizing |V_calc - V_target| or similar
            num_obj += 1
        if opt_conf.get("MtrLengthOpt"):
            num_obj += 1
        if opt_conf.get("MtrRadiusOpt"):
            num_obj += 1
        
        if num_obj <= 0: # From MotorOpt, good to have a fallback or raise error
            print("Warning: No objectives seem to be selected based on OptimizationConf.")
            return 1 # Fallback to at least 1 to avoid errors, or handle as an error
        return num_obj


    def _setup_results_table(self, num_objectives):
        self.ui.tableWidget.clearContents()
        self.ui.tableWidget.setRowCount(0)

        base_headers = ["Gen", "Evals", "NDS", "CV Min", "CV Avg"]
        base_data_keys = ["n_gen", "n_eval", "n_nds", "cv_min", "cv_avg"]

        obj_headers = []
        obj_data_keys = []
        for i in range(num_objectives):
            obj_headers.extend([f"F{i+1} Min", f"F{i+1} Max", f"F{i+1} Avg"])
            obj_data_keys.extend([f"obj{i+1}_min", f"obj{i+1}_max", f"obj{i+1}_avg"])

        all_headers = base_headers + obj_headers
        self.table_column_data_keys = base_data_keys + obj_data_keys # Store for use in _append_results_table_row

        self.ui.tableWidget.setColumnCount(len(all_headers))
        self.ui.tableWidget.setHorizontalHeaderLabels(all_headers)
        self.ui.tableWidget.resizeColumnsToContents() # Optional: auto-resize

    @Slot(dict)
    def _append_results_table_row(self, data_dict):
        if not self.table_column_data_keys: # Headers not set up yet
            print("Warning: Table headers/keys not set up, skipping row append.")
            return

        row_position = self.ui.tableWidget.rowCount()
        self.ui.tableWidget.insertRow(row_position)

        for col_idx, data_key in enumerate(self.table_column_data_keys):
            value = data_dict.get(data_key)
            item_text = ""
            if value is None or (isinstance(value, float) and np.isnan(value)):
                item_text = "N/A"
            elif isinstance(value, float):
                # Smart formatting for floats
                if abs(value) < 1e-3 and value != 0.0 or abs(value) > 1e4:
                    item_text = f"{value:.3e}"
                else:
                    item_text = f"{value:.4f}"
            else:
                item_text = str(value)
            
            table_item = QTableWidgetItem(item_text)
            self.ui.tableWidget.setItem(row_position, col_idx, table_item)
        
        self.ui.tableWidget.scrollToBottom() # Keep last row visible


    def _connect_signals(self):
        # Execution
        self.ui.Execution.clicked.connect(self.start_optimization)
        self.ui.stopButton.clicked.connect(self.stop_optimization)

        # Material property updates
        self.ui.Magnet_Material.currentIndexChanged.connect(self._on_material_changed)
        self.ui.Iron_Material.currentIndexChanged.connect(self._on_material_changed)
        self.ui.Lamination_Material.currentIndexChanged.connect(self._on_material_changed)

        # File Menu Actions
        # Assuming your QAction objects in BLDC_UI.py are named "actionSave" and "actionLoad"
        if hasattr(self.ui, 'actionSave'):
            self.ui.actionSave.triggered.connect(self.save_settings)
        else:
            print("Warning: QAction 'actionSave' not found in UI. Save functionality might not be connected.")
        
        if hasattr(self.ui, 'actionLoad'):
            self.ui.actionLoad.triggered.connect(self.load_settings)
        else:
            print("Warning: QAction 'actionLoad' not found in UI. Load functionality might not be connected.")

        # Plotting (Results Tab)
        # Connect the plot buttons on the Results Tab to their handler slots.
        if hasattr(self.ui, 'ParallelPlot'):
            self.ui.ParallelPlot.clicked.connect(self._handle_parallel_plot)
        else:
            print("Warning: QPushButton 'ParallelPlot' not found in UI.")

        if hasattr(self.ui, 'ThreeDPlot'):
            self.ui.ThreeDPlot.clicked.connect(self._handle_3d_plot)
        else:
            print("Warning: QPushButton 'ThreeDPlot' not found in UI.") 

        # Interface Font Size Scaler
        if hasattr(self.ui, 'font12'): self.ui.font12.triggered.connect(lambda: self._set_font_size(12))
        if hasattr(self.ui, 'font14'): self.ui.font14.triggered.connect(lambda: self._set_font_size(14))
        if hasattr(self.ui, 'font16'): self.ui.font16.triggered.connect(lambda: self._set_font_size(16))
        if hasattr(self.ui, 'font18'): self.ui.font18.triggered.connect(lambda: self._set_font_size(18))
        if hasattr(self.ui, 'font20'): self.ui.font20.triggered.connect(lambda: self._set_font_size(20))
        if hasattr(self.ui, 'font22'): self.ui.font22.triggered.connect(lambda: self._set_font_size(22))

    @Slot(int)
    def _set_font_size(self, size):
        style_sheet = f"* {{ font-size: {size}pt; }}"
        self.setStyleSheet(style_sheet)
        print(f"Application font size forced to {size}pt using stylesheet.")
        vertical_header = self.ui.tableWidget.verticalHeader()
        vertical_header.setSectionResizeMode(QHeaderView.ResizeToContents)
        self.ui.tableWidget.resizeColumnsToContents()
        self.ui.tableWidget.resizeRowsToContents()


    def _get_plot_selections(self):
        """Gathers selected items from checkboxes and dropdowns on the Results tab."""
        # 1. Get selections from checkboxes
        coordvars = [option for widget, option in self.plot_checkboxes if widget.isChecked()]

        # 2. Get selections from dropdowns and map them to MATLAB variable names
        dropdowns = [self.ui.dropdown1, self.ui.dropdown2, self.ui.dropdown3]
        for dropdown in dropdowns:
            selected_text = dropdown.currentText()
            if selected_text and selected_text in self.plot_dropdown_map:
                coordvars.append(self.plot_dropdown_map[selected_text])
        return coordvars

    @Slot()
    def _handle_parallel_plot(self):
        """Handles the Parallel Plot button click."""
        if not self.matlab_engine:
            QMessageBox.critical(self, "MATLAB Error", "MATLAB engine is not available.")
            return

        try:
            coordvars = self._get_plot_selections()
            if not coordvars:
                QMessageBox.warning(self, "Selection Empty", "Please select at least one parameter to plot.")
                return

            print(f"Calling MATLAB UI_ParallelPlot_MATLAB with: {coordvars}")
            self.matlab_engine.UI_ParallelPlot_MATLAB(coordvars, self.recent_excel, nargout=0)
            QMessageBox.information(self, "Plotting", "Sent data to MATLAB for parallel plot.")
        except Exception as e:
            QMessageBox.critical(self, "Plotting Error", f"An error occurred while generating the plot:\n{e}")

    @Slot()
    def _handle_3d_plot(self):
        """Handles the 3D Plot button click."""
        if not self.matlab_engine:
            QMessageBox.critical(self, "MATLAB Error", "MATLAB engine is not available.")
            return

        try:
            coordvars = self._get_plot_selections()
            if len(coordvars) != 3:
                QMessageBox.warning(self, "Selection Error", "For 3D plots, please select exactly 3 parameters.")
                return

            print(f"Calling MATLAB UI_3DPlot_MATLAB with: {coordvars}")
            self.matlab_engine.UI_3DPlot_MATLAB(coordvars, self.recent_excel, nargout=0)
            QMessageBox.information(self, "Plotting", "Sent data to MATLAB for 3D plot.")
        except Exception as e:
            QMessageBox.critical(self, "Plotting Error", f"An error occurred while generating the plot:\n{e}")


    def _update_all_material_properties(self):
        """Helper to update all material properties stored on the instance."""
        material_manager.update_magnet_br_property(self)
        material_manager.update_max_b_magnet_iron_property(self)
        material_manager.update_present_b_lamination_property(self)

    @Slot()
    def _on_material_changed(self):
        """Calls the general update when any material combo box changes."""
        self._update_all_material_properties()

    @Slot()
    def save_settings(self):
        """Slot for saving UI state."""
        state_manager.save_ui_state(self)

    @Slot()
    def load_settings(self):
        """Slot for loading UI state."""
        state_manager.load_ui_state(self)
        self._update_all_material_properties() # Re-apply material properties based on loaded combo box values

    @Slot()
    def stop_optimization(self):
        print("Stop optimization button clicked.")
        if self.optimization_thread and self.optimization_thread.isRunning():
            if self.optimization_worker:
                print("Requesting worker to stop...")
                self.optimization_worker.request_stop() # Signal the worker

            print("Stop request sent to worker. Waiting for thread to finish via signals.")
            self.ui.stopButton.setEnabled(False) # Disable stop button after click
        else:
            print("No optimization running to stop.")
            QMessageBox.information(self, "Not Running", "No optimization process is currently running.")
            self.ui.stopButton.setEnabled(False)
            self.ui.Execution.setEnabled(True)


    @Slot()
    def start_optimization(self):
        if not self.matlab_engine:
            QMessageBox.critical(self, "Error", "MATLAB engine is not running. Cannot start optimization.")
            return

        if self.optimization_thread and self.optimization_thread.isRunning():
            QMessageBox.warning(self, "Busy", "Optimization is already running.")
            return

        try:
            self._update_all_material_properties()
            parameters_pymoo = input_parser.create_pymoo_parameters_from_ui(self)
            optimization_conf = input_parser.read_opt_config_from_ui(self)
            other_opt_args = input_parser.get_other_opt_args(self)

            # --- Store for SaveMat ---
            self.motor_calcs_func_ref = MotorCalcs_Vectorized # Store reference to the function
            self.motor_params_pymoo_ref = parameters_pymoo  # Store the parameters
            self.motor_optimization_conf = optimization_conf   # Store

            #  prepare log table
            num_objectives = self._calculate_num_objectives(optimization_conf)
            if num_objectives <= 0: # Add check based on helper
                 QMessageBox.warning(self, "Input Error", "No objectives selected for optimization. Please check optimization configuration.")
                 return
            self._setup_results_table(num_objectives)

        except (ValueError, AttributeError, PintError) as e:
            QMessageBox.warning(self, "Input Error", f"Error reading inputs: {e}")
            return

        ngens = optimization_conf.get("ngens", 1)
        self.ui.progressBar.setMinimum(0)
        self.ui.progressBar.setMaximum(ngens)
        self.ui.progressBar.setValue(0)
        self.ui.Execution.setEnabled(False)
        self.ui.stopButton.setEnabled(True) # Enable stop button
        print(f"Starting optimization with {ngens} generations.")

        self.optimization_worker = OptimizationWorker(
            MotorCalcs_Vectorized,
            parameters_pymoo,
            optimization_conf,
            other_opt_args,
            MotorOpt # Pass the MotorOpt function itself
        )
        self.optimization_thread = QThread()
        self.optimization_worker.moveToThread(self.optimization_thread)

        self.optimization_worker.table_update_data.connect(self._append_results_table_row)
        self.optimization_thread.started.connect(self.optimization_worker.run_optimization)
        self.optimization_worker.progress_signal.connect(self.update_progress)
        self.optimization_worker.finished_signal.connect(self.on_optimization_finished)
        self.optimization_worker.error_signal.connect(self.on_optimization_error)

        # Graceful cleanup
        self.optimization_worker.finished_signal.connect(self.optimization_thread.quit)
        self.optimization_worker.error_signal.connect(self.optimization_thread.quit) # Also quit thread on error
        self.optimization_worker.finished_signal.connect(self.optimization_worker.deleteLater)
        self.optimization_thread.finished.connect(self.optimization_thread.deleteLater)
        self.optimization_thread.finished.connect(self._on_thread_finished_cleanup) # Centralized cleanup

        self.optimization_thread.start()

    def _on_thread_finished_cleanup(self):
        """Called when the optimization thread actually finishes (either normally or due to error/stop)."""
        print("Optimization thread has finished. Performing cleanup.")
        self.ui.Execution.setEnabled(True)
        self.ui.stopButton.setEnabled(False)
        # ProgressBar is handled by on_optimization_finished or on_optimization_error
        self._cleanup_optimization_references()


    def _cleanup_optimization_references(self):
        """Clear references to worker and thread after they have finished."""
        print("Cleaning up optimization worker and thread references.")
        self.optimization_thread = None
        self.optimization_worker = None

    @Slot(int)
    def update_progress(self, current_generation):
        self.ui.progressBar.setValue(current_generation)

    @Slot(object)
    def on_optimization_finished(self, results):
        print("Optimization finished successfully. Results received in GUI.")
        # self.ui.progressBar.setValue(self.ui.progressBar.maximum()) # Ensure progress bar is full

        if results is None:
            QMessageBox.information(self, "Result", "Optimization finished, but no results object was returned.")
            return

        if not hasattr(results, 'F') or results.F is None:
            QMessageBox.information(self, "Result", "Optimization finished, but no feasible solution (results.F) was found or result format is unexpected.")
        elif not hasattr(results, 'X') or results.X is None:
            QMessageBox.information(self, "Result", "Optimization finished, but no design variables (results.X) were found.")
        else:
            QMessageBox.information(self, "Result", f"Optimization finished. Found {len(results.F)} solution(s).")
            if self.matlab_engine:
                try:
                    # ------------------- NEW CODE: Use QFileDialog -------------------
                    # Define default file name and filter
                    options = QFileDialog.Options()
                    options |= QFileDialog.DontUseNativeDialog
                    file_path, _ = QFileDialog.getSaveFileName(
                        self,
                        "Save Optimization Results",
                        "optimization_results.xlsx", # Default file name
                        "Excel Files (*.xlsx);;All Files (*)",
                        options=options
                    )

                    # If the user cancels the dialog, file_path will be empty
                    if not file_path:
                        print("Save operation cancelled by user.")
                        QMessageBox.information(self, "Save Cancelled", "The results were not saved.")
                        return
                    else:
                        self.recent_excel = file_path

                    print("Attempting to automatically save optimization results...")
                    mag_br, max_b_mag, pres_b_lam, _, _, _, _, _ = input_parser.get_other_opt_args(self)
                    if self.motor_calcs_func_ref is None or self.motor_params_pymoo_ref is None:
                        print("Error: References for SaveMat (calc_function or pymoo_params_dict) are missing.")
                        QMessageBox.warning(self, "Save Error", "Could not save results: Internal data missing for SaveMat.")
                        return
                    
                    # Pass the new file_path variable to the function
                    SaveMat(self.matlab_engine, results.X, results.F, results.G, self.motor_optimization_conf, self.motor_params_pymoo_ref, mag_br, max_b_mag, pres_b_lam, file_path)
                    
                    print(f"Optimization results successfully saved to: {file_path}")
                    
                    # Direct User to begin plotting in results tab
                    QMessageBox.information(self, "Save Complete, Plotting Ready",
                                          f"Optimization complete and results are saved to:\n{file_path}\n\n"
                                          "You can now go to the 'Results' tab to generate plots.")
                    if hasattr(self.ui, 'tab_4'):
                        self.ui.tabWidget.setCurrentWidget(self.ui.tab_4)

                except AttributeError as ae:
                    print(f"Error preparing data for SaveMat: Missing attribute - {ae}")
                    QMessageBox.warning(self, "Save Error", f"Could not save results: Missing data for SaveMat.\nDetails: {ae}")
                except Exception as e:
                    print(f"Error during automatic save of results: {e}")
                    detailed_error = traceback.format_exc()
                    QMessageBox.warning(self, "Save Error", f"Could not automatically save results to an Excel file:\n{e}\n\nDetails:\n{detailed_error}")
            else:
                print("MATLAB engine not running. Cannot save results automatically.")
                QMessageBox.warning(self, "Save Skipped", "MATLAB engine not available. Results not saved automatically.")

    @Slot(str)
    def on_optimization_error(self, error_message):
        print(f"Optimization error received in GUI: {error_message}")
        if "stopped by user" in error_message.lower():
            QMessageBox.information(self, "Optimization Stopped", "The optimization process was stopped by the user.")
        else:
            QMessageBox.critical(self, "Optimization Error", error_message)
        self.ui.progressBar.setValue(0) # Reset progress bar
        # Cleanup is handled by _on_thread_finished_cleanup via thread.finished signal

    def closeEvent(self, event):
        if self.optimization_thread and self.optimization_thread.isRunning():
            reply = QMessageBox.question(self, 'Application Busy',
                                         "Optimization is currently running. Are you sure you want to quit? "
                                         "This may leave the MATLAB engine in an unstable state if not stopped properly.",
                                         QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.No:
                event.ignore()
                return
            else:
                print("Attempting to stop optimization before closing...")
                if self.optimization_worker:
                    self.optimization_worker.request_stop()

                if self.optimization_thread.isRunning():
                    print("Attempting to quit optimization thread...")
                    self.optimization_thread.quit()
                    if not self.optimization_thread.wait(5000): # Wait up to 5 seconds
                        print("Optimization thread did not quit gracefully, terminating...")
                        self.optimization_thread.terminate()
                        self.optimization_thread.wait()
        if self.matlab_engine:
            print("Stopping MATLAB engine...")
            try:
                self.matlab_engine.quit()
                print("MATLAB engine stopped.")
            except Exception as e:
                print(f"Error stopping MATLAB engine: {e}")
        event.accept()



def run():
    app = QApplication(sys.argv)
    mainWin = MainWindow()
    mainWin.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    run()