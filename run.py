# I converted the Notebook file into a standard python file
import sys
from PySide2.QtWidgets import QApplication, QMainWindow
from BLDC_UI import Ui_MainWindow  # Import the UI class generated by Qt Designer
from pint import UnitRegistry  # Import Pint for unit conversion
from pymoo.core.variable import Real, Integer, Choice, Binary  # Import Pymoo variable types
from UI_MotorOptimizer import MotorOpt
from UI_MotorModel import MotorCalcs_Vectorized
import matlab.engine 
eng = matlab.engine.start_matlab()


# Worker Thread for running the optimization without freezing the GUI
class OptimizationWorker(QObject):
    finished = Signal(object) # Emits the result object when done
    error = Signal(str)     # Emits error messages

    def __init__(self, motor_calcs_func, params, mag_br, max_b_mag_iron, present_b_lam, eng, real_type, int_type, choice_type, bin_type, opt_conf, callback):
        super().__init__()
        self.motor_calcs_func = motor_calcs_func
        self.params = params
        self.mag_br = mag_br
        self.max_b_mag_iron = max_b_mag_iron
        self.present_b_lam = present_b_lam
        self.eng = eng
        self.real_type = real_type
        self.int_type = int_type
        self.choice_type = choice_type
        self.bin_type = bin_type
        self.opt_conf = opt_conf
        self.callback = callback # The progress callback instance

    @Slot()
    def run(self):
        try:
          result = MotorOpt(
                self.motor_calcs_func,
                self.params,
                self.mag_br,
                self.max_b_mag_iron,
                self.present_b_lam,
                self.eng,
                self.real_type, # Pass the type/class
                self.int_type,  # Pass the type/class
                self.choice_type,# Pass the type/class
                self.bin_type,  # Pass the type/class
                self.opt_conf,
                self.callback      # Pass the callback instance
            )
            self.finished.emit(result)
        except Exception as e:
            self.error.emit(f"Optimization Error: {e}\n{traceback.format_exc()}") # Include traceback
        finally:
            # Clean up MATLAB engine if needed (depends on your eng management)
            # if self.eng:
            #     self.eng.quit()
            pass


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)

        # --- Member variables ---
        self.optimization_thread = None
        self.optimization_worker = None
        self.matlab_engine = None # Initialize your MATLAB engine here if needed
        self.optimization_results = None

        # --- Connect Signals ---
        self.ui.Execution.clicked.connect(self.start_optimization)
    
    def optimizer(self):
        variables = {}
        parameters = {} 
        OptimizationConf = {}

        # Collect user inputs from the UI elements
        variables['I_PolePair'] = self.ui.I_PolePair_1.value()
        variables['R_MagnetRadialLength'] = self.ui.R_MagnetRadialLength_1.value()
        variables['R_MagnetOutR'] = self.ui.R_MagnetOutR_1.value()
        variables['R_MagnetBackIronInnerR'] = self.ui.R_MagnetBackIronInnerR_1.value()
        variables['R_MagneticLossCoef1'] = self.ui.R_MagneticLossCoef1_1.value()
        variables['R_MagneticLossCoef2'] = self.ui.R_MagneticLossCoef2_1.value()
        variables['R_MagneticLossCoef3'] = self.ui.R_MagneticLossCoef3_1.value()
        variables['I_NumElecPhase'] = self.ui.I_NumElecPhase_1.value()
        variables['R_PhaseCurrentAmp'] = self.ui.R_PhaseCurrentAmp_1.value()
        variables['R_WireCopperR'] = self.ui.R_WireCopperR_1.value()
        variables['R_InsulThick'] = self.ui.R_InsulThick_1.value()
        variables['R_FillFactor'] = self.ui.R_FillFactor_1.value()
        variables['R_LaminatToothWedgeThickness'] = self.ui.R_LaminatToothWedgeThickness_1.value()
        variables['R_LaminatR'] = self.ui.R_LaminatR_1.value()
        variables['R_LamSlotLinerThick'] = self.ui.R_LamSlotLinerThick_1.value()
        variables['R_LoadInertia'] = self.ui.R_LoadInertia_1.value()
        variables['R_GearRatio'] = self.ui.R_GearRatio_1.value()
        variables['R_MtrLength'] = self.ui.R_MtrLength_1.value()
        variables['R_FluidSpecificGrav'] = self.ui.R_FluidSpecificGrav_1.value()
        variables['R_FluidKinVisc'] = self.ui.R_FluidKinVisc_1.value()
        variables['R_AirgapRadialLength'] = self.ui.R_AirgapRadialLength_1.value()
        variables['R_VacMagneticPerm'] = self.ui.R_VacMagneticPerm_1.value()
        
        OptimizationConf['SpeedReq'] = self.ui.SpeedReq.text()
        OptimizationConf['MinTor'] = self.ui.MinTor.text()
        OptimizationConf['MinEff_'] = self.ui.MinEff_.value()
        OptimizationConf['MaxWeight'] = self.ui.MaxWeight.value()
        OptimizationConf['VDC'] = self.ui.VDC.value()
        OptimizationConf['TorqueOpt'] = self.ui.TorqueOpt.isChecked()
        OptimizationConf['EfficinecyOpt_min'] = self.ui.EfficinecyOpt_min.isChecked()
        OptimizationConf['EfficinecyOpt_max'] = self.ui.EfficinecyOpt_max.isChecked()
        OptimizationConf['WeightOpt'] = self.ui.WeightOpt.isChecked()
        OptimizationConf['MagWeightOpt'] = self.ui.MagWeightOpt.isChecked()
        OptimizationConf['VoltageOpt'] = self.ui.VoltageOpt.isChecked()
        OptimizationConf['MtrLengthOpt'] = self.ui.MtrLengthOpt.isChecked()
        OptimizationConf['MtrRadiusOpt'] = self.ui.MtrRadiusOpt.isChecked()
        OptimizationConf['npop'] = self.ui.npop.value()
        OptimizationConf['ngens'] = self.ui.ngens.value()
        OptimizationConf['nprocesses'] = self.ui.nprocesses.value()
        OptimizationConf['DisMut'] = self.ui.DisMut.value()
        OptimizationConf['ProbMut'] = self.ui.ProbMut.value()
        

        #print(OptimizationConf.get("SpeedReq"))
        self.update_magnet_br()
        self.update_max_b_magnet_iron()  # Update MaxBMagnetIron_T based on current selection
        self.update_present_b_lamination()  # Update PresentBLaminationBackIron_T based on current selection

        for key, value in variables.items():
            if isinstance(value, int):
                parameters[key] = Integer(value=value, bounds=(getattr(self.ui, key + '_1').value(), getattr(self.ui, key + '_2').value()))
            elif isinstance(value, float): 

                # unit = getattr(self.ui, key + '_unit').value()
                # print(unit)
                parameters[key] = Real(value=value, bounds=(getattr(self.ui, key + '_1').value(), getattr(self.ui, key + '_2').value()))

        res = MotorOpt(MotorCalcs_Vectorized, parameters, self.MagnetBr_T, self.MaxBMagnetIron_T, self.PresentBLaminationBackIron_T \
                       ,eng, Real, Integer, Choice, Binary,OptimizationConf) 
    

    def update_magnet_br(self):
        # Define the dictionary mapping materials to their float values
        magnet_br_values = {
            "Recoma 18": 0.87,
            "Recoma 20": 0.90,
            "Recoma 22": 0.94,
            "Recoma 25": 1.00,
            "Recoma 24HE": 1.02,
            "Recoma 26": 1.04,
            "Recoma 26HE": 1.07,
            "Recoma 28": 1.10,
            "Recoma 28HE": 1.10,
            "Recoma 30": 1.12,
            "Recoma 30HE": 1.12,
            "Recoma 30S": 1.12,
            "Recoma 32": 1.15,
            "Recoma 32S": 1.15,
            "Recoma 33E": 1.16,
            "Recoma 35E": 1.19,
        }
    
        # Get the selected material from the QComboBox
        selected_material = self.ui.Magnet_Material.currentText()
        self.MagnetBr_T = magnet_br_values.get(selected_material, 1.1)

    def update_max_b_magnet_iron(self):
        """Update the MaxBMagnetIron_T based on the selected iron material."""
        selected_option = self.ui.Iron_Material.currentText()
        iron_br_values = {
            "430 Stainless Steel": 1.3,
            "1215 Steel": 1.5,
            "1018 Steel": 1.4,
            "1008 Steel": 1.4,
            "1010 Steel": 1.4,
            "Hiperco 50": 2.0,
            "M19": 1.75,
        }
        self.MaxBMagnetIron_T = iron_br_values.get(selected_option, 1.5)  # Default to 1.5 if not found

    def update_present_b_lamination(self):
        """Update the PresentBLaminationBackIron_T based on the selected lamination material."""
        selected_option = self.ui.Lamination_Material.currentText()
        lamination_br_values = {
            "M19": 1.75,
            "Hiperco 50": 2.3,
        }
        self.PresentBLaminationBackIron_T = lamination_br_values.get(selected_option, 1.75)  # Default to 1.75 if not found


    def get_unit(self, variable_name):
        """Return the unit corresponding to the variable name."""
        # Mapping of variable names to units
        unit_map = {
            'R_MagnetRadialLength': 'meter',  # Example: replace with actual units
            'R_MagnetOutR': 'meter',
            'R_MagnetBackIronInnerR': 'meter',
            'R_MagneticLossCoef1': '1',  # Dimensionless
            'R_MagneticLossCoef2': '1',
            'R_MagneticLossCoef3': '1',
            'R_PhaseCurrentAmp': 'ampere',
            'R_WireCopperR': 'meter',
            'R_InsulThick': 'meter',
            'R_FillFactor': '1',  # Dimensionless
            'R_LaminatToothWedgeThickness': 'meter',
            'R_LaminatR': 'meter',
            'R_LoadInertia': 'kg*m^2',
            'R_GearRatio': '1',  # Dimensionless
            'R_MtrLength': 'meter',
            'R_FluidSpecificGrav': '1',  # Dimensionless
            'R_FluidKinVisc': 'cSt',
            'R_AirgapRadialLength': 'meter',
            'R_VacMagneticPerm': 'H/m',
        }
        return unit_map.get(variable_name, 'meter')  # Default to 'meter' if not found


if __name__ == "__main__":
    app = QApplication(sys.argv)
    mainWin = MainWindow()
    mainWin.show()
    sys.exit(app.exec_())